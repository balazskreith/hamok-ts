import { EventEmitter } from 'events';
import { HamokMessage, HamokMessage_MessageType as HamokMessageType } from '../messages/HamokMessage';
import { GetEntriesRequest, GetEntriesResponse } from '../messages/messagetypes/GetEntries';
import { StorageCodec } from '../messages/StorageCodec';
import { v4 as uuid } from 'uuid';
import { createLogger } from '../common/logger';
import { PendingRequest } from '../messages/PendingRequest';
import { OngoingRequestsNotification } from '../messages/messagetypes/OngoingRequests';
import { ClearEntriesRequest, ClearEntriesNotification, ClearEntriesResponse } from '../messages/messagetypes/ClearEntries';
import { DeleteEntriesRequest, DeleteEntriesNotification, DeleteEntriesResponse } from '../messages/messagetypes/DeleteEntries';
import { EvictEntriesRequest, EvictEntriesNotification, EvictEntriesResponse } from '../messages/messagetypes/EvictEntries';
import { GetKeysRequest } from '../messages/messagetypes/GetKeys';
import { GetSizeRequest } from '../messages/messagetypes/GetSize';
import { InsertEntriesRequest, InsertEntriesNotification, InsertEntriesResponse } from '../messages/messagetypes/InsertEntries';
import { RemoveEntriesRequest, RemoveEntriesNotification, RemoveEntriesResponse } from '../messages/messagetypes/RemoveEntries';
import { RestoreEntriesRequest, RestoreEntriesNotification, RestoreEntriesResponse } from '../messages/messagetypes/RestoreEntries';
import { UpdateEntriesRequest, UpdateEntriesNotification, UpdateEntriesResponse } from '../messages/messagetypes/UpdateEntries';
import { PendingResponse } from '../messages/PendingResponse';
import { createResponseChunker, ResponseChunker } from '../messages/ResponseChunker';
import * as Collections from '../common/Collections';
import { OngoingRequestsNotifier } from '../messages/OngoingRequestsNotifier';

const logger = createLogger('StorageConnection');

export type StorageConnectionConfig = {

	/**
     * The identifier of the storage the comlink belongs to.
     * In case of a storage builder this infromation is automatically fetched 
     * from the given storage.
     */
	storageId: string,

	/**
         * Determining the timeout for a request generated by this comlink.
         * in case of a storage builder belongs to a hamok grid, the default value is 
         * the grid request timeout config setting
         */
	requestTimeoutInMs: number,

	/**
     * Determine how many response is necessary to resolve the request. 
     */
	neededResponse: number,

	submitting?: ReadonlySet<HamokMessageType>,

	/**
     * The maximum number of keys a response can contain.
     */
	maxResponseKeys?: number,

	/**
     * The maximum number of values a response can contain.
     */
	maxResponseValues?: number,

	/**
     * In case a requestId is added explicitly to the ongoing requests set
     * by calling the addOngoingRequestId() this setting determines the period 
     * to send notification to the source(s) about an ongoing requests to prevent timeout there
     * The notification stopped sent if removeOngoingRequestId is called, and it is very important 
     * to call it explicitly in any case. In another word comlink is not responsible to handle 
     * automatically an explicitly postponed request to stop sending notification about.
     */
	ongoingRequestsSendingPeriodInMs: number;
}

export type StorageConnectionEventMap<K, V> = {
	'message': [message: HamokMessage, submit: boolean],
	close: [],

	OngoingRequestsNotification: [OngoingRequestsNotification];
	ClearEntriesRequest: [ClearEntriesRequest];
	ClearEntriesNotification: [ClearEntriesNotification];
	GetEntriesRequest: [GetEntriesRequest<K>];
	GetKeysRequest: [GetKeysRequest];
	GetSizeRequest: [GetSizeRequest];
	DeleteEntriesRequest: [DeleteEntriesRequest<K>];
	DeleteEntriesNotification: [DeleteEntriesNotification<K>];
	RemoveEntriesRequest: [RemoveEntriesRequest<K>];
	RemoveEntriesNotification: [RemoveEntriesNotification<K>];
	EvictEntriesRequest: [EvictEntriesRequest<K>];
	EvictEntriesNotification: [EvictEntriesNotification<K>];
	InsertEntriesRequest: [InsertEntriesRequest<K, V>];
	InsertEntriesNotification: [InsertEntriesNotification<K, V>];
	UpdateEntriesRequest: [UpdateEntriesRequest<K, V>];
	UpdateEntriesNotification: [UpdateEntriesNotification<K, V>];
	RestoreEntriesRequest: [RestoreEntriesRequest<K, V>];
	RestoreEntriesNotification: [RestoreEntriesNotification<K, V>];
}

export type StorageConnectionResponseMap<K, V> = {
	GetEntriesResponse: GetEntriesResponse<K, V>;
	ClearEntriesResponse: ClearEntriesResponse;
	DeleteEntriesResponse: DeleteEntriesResponse<K>;
	RemoveEntriesResponse: RemoveEntriesResponse<K, V>;
	EvictEntriesResponse: EvictEntriesResponse;
	InsertEntriesResponse: InsertEntriesResponse<K, V>;
	UpdateEntriesResponse: UpdateEntriesResponse<K, V>;
	RestoreEntriesResponse: RestoreEntriesResponse;
}

export type StorageConnectionNotificationMap<K, V> = {
	OngoingRequestsNotification: OngoingRequestsNotification;
	ClearEntriesNotification: ClearEntriesNotification;
	DeleteEntriesNotification: DeleteEntriesNotification<K>;
	RemoveEntriesNotification: RemoveEntriesNotification<K>;
	EvictEntriesNotification: EvictEntriesNotification<K>;
	InsertEntriesNotification: InsertEntriesNotification<K, V>;
	UpdateEntriesNotification: UpdateEntriesNotification<K, V>;
	RestoreEntriesNotification: RestoreEntriesNotification<K, V>;
}

export class StorageConnection<K, V> extends EventEmitter<StorageConnectionEventMap<K, V>> {
	private readonly _pendingRequests = new Map<string, PendingRequest>();
	private readonly _pendingResponses = new Map<string, PendingResponse>();
	private readonly _responseChunker: ResponseChunker;

	private _closed = false;

	public constructor(
		private readonly config: StorageConnectionConfig,
		public readonly codec: StorageCodec<K, V>,
		public readonly remotePeers: ReadonlySet<string>,
		public readonly ongoingRequestsNotifier: OngoingRequestsNotifier,
	) {
		super();

		this._responseChunker = createResponseChunker(
			config.maxResponseKeys ?? 0,
			config.maxResponseValues ?? 0,
		);

		// this is emitted by the Hamok instance
		this.on('OngoingRequestsNotification', (notification) => {
			notification.requestIds.forEach((requestId) => {
				this._pendingRequests.get(requestId)?.postponeTimeout();
			});
		});
	}

	public get closed() {
		return this._closed;
	}

	public close() {
		if (this._closed) return;
		this._closed = true;

		for (const pendingRequest of this._pendingRequests.values()) {
			pendingRequest.reject('Connection is closed');
			this.ongoingRequestsNotifier.remove(pendingRequest.id);
		}
		this._pendingRequests.clear();
		this._pendingResponses.clear();

		this.emit('close');

		this.removeAllListeners();
	}

	public accept(message: HamokMessage) {
		switch (message.type) {
			case HamokMessageType.ADD_SUBSCRIPTION_RESPONSE:
			case HamokMessageType.REMOVE_SUBSCRIPTION_RESPONSE:
			case HamokMessageType.GET_ENTRIES_RESPONSE:
			case HamokMessageType.GET_KEYS_RESPONSE:
			case HamokMessageType.GET_SIZE_RESPONSE:
			case HamokMessageType.CLEAR_ENTRIES_RESPONSE:
			case HamokMessageType.DELETE_ENTRIES_RESPONSE:
			case HamokMessageType.REMOVE_ENTRIES_RESPONSE:
			case HamokMessageType.EVICT_ENTRIES_RESPONSE:
			case HamokMessageType.INSERT_ENTRIES_RESPONSE:
			case HamokMessageType.UPDATE_ENTRIES_RESPONSE:
			case HamokMessageType.RESTORE_ENTRIES_RESPONSE:
				return this._processResponse(message);
		}

		this.codec.decode(message, this._emitDecoded.bind(this));
	}

	private _emitDecoded(type: string, output: unknown) {
		if (!(this as EventEmitter).emit(type, output)) {
			logger.warn('Unhandled message type %s', type);
		}
	}

	public async getEntries(
		keys: ReadonlySet<K>,
		targetPeerIds?: ReadonlySet<string>
	): Promise<ReadonlyMap<K, V>> {
		const requestId = uuid();
		const message = this.codec.encodeGetEntriesRequest(
			new GetEntriesRequest(
				keys,
				requestId,
			)
		);
		const result = new Map<K, V>();

		(await this._request({
			message, 
			targetPeerIds
		}))
			.map((response) => this.codec.decodeGetEntriesResponse(response))
			.forEach((response) => Collections.concatMaps(
				result,
				response.foundEntries
			));
		
		return result;
	}

	public respond<U extends keyof StorageConnectionResponseMap<K, V>>(type: U, response: StorageConnectionResponseMap<K, V>[U], targetPeerIds?: string | string[]): void {
		let message: HamokMessage | undefined;

		switch (type) {
			case 'GetEntriesResponse':
				message = this.codec.encodeGetEntriesResponse(response as GetEntriesResponse<K, V>);
				break;
			case 'ClearEntriesResponse':
				message = this.codec.encodeClearEntriesResponse(response as ClearEntriesResponse);
				break;
			case 'DeleteEntriesResponse':
				message = this.codec.encodeDeleteEntriesResponse(response as DeleteEntriesResponse<K>);
				break;
			case 'RemoveEntriesResponse':
				message = this.codec.encodeRemoveEntriesResponse(response as RemoveEntriesResponse<K, V>);
				break;
			case 'EvictEntriesResponse':
				message = this.codec.encodeEvictEntriesResponse(response as EvictEntriesResponse);
				break;
			case 'InsertEntriesResponse':
				message = this.codec.encodeInsertEntriesResponse(response as InsertEntriesResponse<K, V>);
				break;
			case 'UpdateEntriesResponse':
				message = this.codec.encodeUpdateEntriesResponse(response as UpdateEntriesResponse<K, V>);
				break;
			case 'RestoreEntriesResponse':
				message = this.codec.encodeRestoreEntriesResponse(response as RestoreEntriesResponse);
				break;
		}
		if (!message) {
			return logger.warn('Cannot encode response for type %s', type);
		}

		for (const chunk of this._responseChunker.apply(message)) {
			// logger.info("Sending response message", message.type);
			this._sendMessage(
				chunk,
				targetPeerIds ? new Set(Array.isArray(targetPeerIds) ? targetPeerIds : [ targetPeerIds ]) : undefined
			);
		}
	}

	public notify<U extends keyof StorageConnectionNotificationMap<K, V>>(type: U, notification: StorageConnectionNotificationMap<K, V>[U], targetPeerIds?: string[]) {
		let message: HamokMessage | undefined;

		switch (type) {
			case 'OngoingRequestsNotification':
				message = this.codec.encodeOngoingRequestsNotification(notification as OngoingRequestsNotification);
				break;
			case 'ClearEntriesNotification':
				message = this.codec.encodeClearEntriesNotification(notification as ClearEntriesNotification);
				break;
			case 'DeleteEntriesNotification':
				message = this.codec.encodeDeleteEntriesNotification(notification as DeleteEntriesNotification<K>);
				break;
			case 'RemoveEntriesNotification':
				message = this.codec.encodeRemoveEntriesNotification(notification as RemoveEntriesNotification<K>);
				break;
			case 'EvictEntriesNotification':
				message = this.codec.encodeEvictEntriesNotification(notification as EvictEntriesNotification<K>);
				break;
			case 'InsertEntriesNotification':
				message = this.codec.encodeInsertEntriesNotification(notification as InsertEntriesNotification<K, V>);
				break;
			case 'UpdateEntriesNotification':
				message = this.codec.encodeUpdateEntriesNotification(notification as UpdateEntriesNotification<K, V>);
				break;
			case 'RestoreEntriesNotification':
				message = this.codec.encodeRestoreEntriesNotification(notification as RestoreEntriesNotification<K, V>);
				break;
		}

		if (!message) {
			return logger.warn('Cannot encode notification for type %s', type);
		}

		this._sendMessage(
			message,
			targetPeerIds ? new Set(targetPeerIds) : undefined
		);
	}

	private async _request(options: {
		message: HamokMessage, 
		targetPeerIds?: ReadonlySet<string>, 
	}): Promise<HamokMessage[]> {
		const requestId = options.message.requestId;

		if (!requestId) {
			logger.warn('Cannot send request message without a requestId %o', options.message);
			
			return Promise.resolve([]);
		}
		const remotePeers = options.targetPeerIds ?? this.remotePeers;
		const pendingRequest = new PendingRequest({
			requestId,
			neededResponses: this.config.neededResponse,
			remotePeers,
			timeoutInMs: this.config.requestTimeoutInMs,
		});
		const prevPendingRequest = this._pendingRequests.get(pendingRequest.id);

		if (prevPendingRequest) {
			prevPendingRequest.reject('Request is overridden');
		}
		this._pendingRequests.set(pendingRequest.id, pendingRequest);
		try {
			this._sendMessage(options.message, remotePeers);
			const response = await pendingRequest;

			return response;
		} finally {
			this._purgeResponseForRequest(requestId!);
			this._pendingRequests.delete(pendingRequest.id);
		}
	}

	private _processResponse(message: HamokMessage): void {
		if (!message.requestId || !message.sourceId) {
			logger.warn('_processResponse(): Message does not have a requestId or sourceId. message: %o', message);
			
			return;
		}
		const chunkedResponse = message.sequence !== undefined && message.lastMessage !== undefined;
		const onlyOneChunkExists = message.sequence === 0 && message.lastMessage === true;
		// console.warn("_responseReceived ", message);

		if (chunkedResponse && !onlyOneChunkExists) {
			const pendingResponseId = `${message.sourceId}#${message.requestId}`;
			let pendingResponse = this._pendingResponses.get(pendingResponseId);

			if (!pendingResponse) {
				pendingResponse = new PendingResponse({
					requestId: message.requestId,
					sourcePeerId: message.sourceId,
				});
				this._pendingResponses.set(pendingResponseId, pendingResponse);
			}
			pendingResponse.accept(message);
			if (!pendingResponse.isReady) {
				const pendingRequest = this._pendingRequests.get(message.requestId ?? 'notExists');
				// let's postpone the timeout if we knoe responses are coming

				if (pendingRequest) {
					pendingRequest.postponeTimeout();
				}
				
				return;
			}
			if (!this._pendingResponses.delete(pendingResponseId)) {
				logger.warn(`Unsuccessful deleting for pending response ${pendingResponseId}`);
			}
			const assembledResponse = pendingResponse.result;

			if (!assembledResponse) {
				logger.warn(`Undefined Assembled response, cannot make a response for request ${message.requestId}`, message);
				
				return;
			}
			message = assembledResponse;
		}
		if (!message.requestId) {
			logger.warn('response message does not have a requestId', message);
			
			return;
		}
		const pendingRequest = this._pendingRequests.get(message.requestId);

		if (!pendingRequest) {
			logger.warn(`Cannot find pending request for requestId ${message.requestId}`, message);
			
			return;
		}
		if (pendingRequest.completed) {
			logger.warn('Response is received for an already completed request. pendingRequest: %o, response: %o', pendingRequest, message);
			
			return;
		}
		pendingRequest.accept(message);
	}

	private _sendMessage(
		message: HamokMessage, 
		destinationPeerIds?: ReadonlySet<string>,
	) {
		message.storageId = this.config.storageId;
		const submit = message.type ? this.config.submitting?.has(message.type) ?? false : false;

		if (!destinationPeerIds) {
			return this.emit('message', message, submit);
		} else if (destinationPeerIds.size < 1) {
			return logger.warn('Empty set of destination has been provided for request %o', message);   
		} else if (destinationPeerIds.size === 1) {
			for (const destinationId of destinationPeerIds) {
				message.destinationId = destinationId;
				this.emit('message', message, submit);
			}
		} else {
			for (const destinationId of destinationPeerIds) {
				this.emit('message', new HamokMessage({
					...message,
					destinationId
				}), submit);
			}
		}
	}

	private _purgeResponseForRequest(requestId: string) {
		const pendingResponseKeys: string[] = [];

		for (const [ key, pendingResponse ] of this._pendingResponses) {
			if (pendingResponse.requestId === requestId) {
				pendingResponseKeys.push(key);
			}
		}
		pendingResponseKeys.forEach((pendingResponseKey) => this._pendingResponses.delete(pendingResponseKey));
	}
	
}